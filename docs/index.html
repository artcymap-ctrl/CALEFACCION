<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Temperaturas horarias · Vitoria-Gasteiz (Foronda 9091R)</title>
  <style>
    :root{--bg:#0b1220;--fg:#e7eef7;--muted:#9db0c6;--card:#121a2b;--accent:#4aa3ff}
    *{box-sizing:border-box} body{margin:0;background:var(--bg);color:var(--fg);font-family:system-ui,Segoe UI,Roboto,Arial}
    header{padding:16px;border-bottom:1px solid #1c2740;background:linear-gradient(180deg,#0d1628 0%, #0b1220 60%)}
    h1{font-size:1.05rem;margin:0 0 2px 0} .sub{color:var(--muted);font-size:.88rem}
    main{padding:16px}
    .card{background:var(--card);border:1px solid #1c2740;border-radius:12px;padding:14px}
    .toprow{display:flex;justify-content:space-between;align-items:center;margin-bottom:10px}
    a{color:#9fd1ff} .muted{color:var(--muted)} .err{color:#ff6b6b}
    #chart{width:100%;height:58vh;min-height:340px;background:#0b1324;border:1px solid #1c2740;border-radius:8px}
  </style>
  <!-- Chart.js + date adapter (imprescindible para ejes temporales) -->
  <script src="https://cdn.jsdelivr.net/npm/date-fns@2.30.0/dist/date-fns.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.umd.min.js"></script>
</head>
<body>
  <header>
    <h1>Temperaturas horarias · Vitoria-Gasteiz (Foronda 9091R)</h1>
    <div class="sub">Fuente: AEMET · captura diaria automática · histórico incremental</div>
  </header>

  <main>
    <div class="card">
      <div class="toprow">
        <div>CSV histórico: <a id="csvLink" href="#" target="_blank" rel="noopener">data/9091R_temp_history.csv</a></div>
        <div class="muted">Último dato: <span id="updatedLbl">—</span></div>
      </div>
      <canvas id="chart"></canvas>
      <div id="msg" class="muted" style="margin-top:8px"></div>
    </div>
  </main>

<script>
(async function () {
  // 1) URL del CSV (raw en main)
  const CSV_URL = 'https://raw.githubusercontent.com/artcymap-ctrl/CALEFACCION/main/data/9091R_temp_history.csv';

  const csvLink   = document.getElementById('csvLink');
  const updatedLbl= document.getElementById('updatedLbl');
  const msg       = document.getElementById('msg');
  csvLink.href = CSV_URL;
  csvLink.textContent = 'data/9091R_temp_history.csv';

  // Utilidad: parseo CSV robusto (simple y suficiente)
  function parseCSV(text) {
    const lines = text.trim().split(/\r?\n/);
    if (!lines.length) return [];
    const headers = lines[0].split(',').map(h => h.trim());
    const rows = [];
    for (let i = 1; i < lines.length; i++) {
      const parts = lines[i].split(',');
      if (parts.length !== headers.length) continue;
      const o = {};
      for (let j = 0; j < headers.length; j++) {
        o[headers[j]] = parts[j].trim();
      }
      rows.push(o);
    }
    return { headers, rows };
  }

  // Localiza nombres de columna de forma flexible
  function pickColumns(headers) {
    const h = headers.map(x => x.toLowerCase());
    const find = (...cands) => {
      for (const c of cands) {
        const idx = h.indexOf(c.toLowerCase());
        if (idx !== -1) return headers[idx];
      }
      return null;
    };
    const colDT  = find('datetime_utc','time_utc','datetime','fecha_hora_utc','time_iso');
    const colT   = find('temp_c','ta','temperatura (ºc)','temperatura','t');
    const colDL  = find('date_local','fecha_local','fecha');
    const colTL  = find('time_local','hora_local','hora');
    return { colDT, colT, colDL, colTL };
  }

  // Intenta crear Date a partir de distintas formas
  function parseWhen(row, cols) {
    if (cols.colDT && row[cols.colDT]) {
      const d = new Date(row[cols.colDT]);      // ISO UTC del CSV
      if (!Number.isNaN(d.getTime())) return d;
    }
    if (cols.colDL && cols.colTL && row[cols.colDL] && row[cols.colTL]) {
      // Asumimos que date_local+time_local están en hora local (Europe/Madrid)
      // Construimos como local. Nota: no ajustamos manualmente DST aquí;
      // para la gráfica es suficiente trabajar en "hora local" del navegador.
      const s = row[cols.colDL] + ' ' + row[cols.colTL];
      const d = new Date(s);
      if (!Number.isNaN(d.getTime())) return d;
    }
    return null;
  }

  // 2) Descarga
  let text;
  try {
    const r = await fetch(CSV_URL, { cache: 'no-store' });
    if (!r.ok) throw new Error('HTTP '+r.status);
    text = await r.text();
  } catch (e) {
    msg.className = 'err';
    msg.textContent = 'Error cargando CSV: ' + (e && e.message ? e.message : e);
    return;
  }

  // 3) Parseo
  const parsed = parseCSV(text);
  if (!parsed.rows.length) {
    msg.className = 'err';
    msg.textContent = 'CSV vacío o sin filas de datos.';
    return;
  }
  const cols = pickColumns(parsed.headers);
  if (!cols.colT || (!cols.colDT && !(cols.colDL && cols.colTL))) {
    msg.className = 'err';
    msg.textContent = 'No encuentro columnas de fecha/hora y temperatura esperadas. Cabeceras: ' + parsed.headers.join(', ');
    return;
  }

  // 4) Normaliza datos
  const points = [];
  for (const row of parsed.rows) {
    const when = parseWhen(row, cols);
    let t = row[cols.colT];
    if (t == null || t === '') continue;
    t = Number(String(t).replace(',', '.'));
    if (!when || Number.isNaN(t)) continue;
    points.push({ x: when, y: t });
  }
  points.sort((a,b)=>a.x - b.x);

  if (!points.length) {
    msg.className = 'err';
    msg.textContent = 'No hay puntos válidos tras normalizar.';
    return;
  }

  // 5) Último dato
  const last = points[points.length-1];
  updatedLbl.textContent = last.x.toLocaleString('es-ES');

  // 6) Escalas sugeridas
  const ys = points.map(p => p.y);
  const yMin = Math.min(...ys), yMax = Math.max(...ys);
  const span = Math.max(1e-6, yMax - yMin);
  const pad = Math.max(0.5, Math.min(2.5, span * 0.15));

  // 7) Gráfica
  const ctx = document.getElementById('chart').getContext('2d');
  new Chart(ctx, {
    type: 'line',
    data: {
      datasets: [{
        label: 'Temperatura (ºC)',
        data: points,
        parsing: false,            // ya pasamos {x,y}
        borderWidth: 2,
        pointRadius: 0,
        tension: 0.2
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      animation: false,
      scales: {
        x: {
          type: 'time',
          time: { tooltipFormat: "dd/MM/yyyy HH:mm", displayFormats: { hour: "HH:mm" } },
          ticks: { color: '#a9c2de' },
          title: { display: true, text: 'Fecha y hora' }
        },
        y: {
          suggestedMin: Math.floor((yMin - pad)*10)/10,
          suggestedMax: Math.ceil((yMax + pad)*10)/10,
          ticks: { color: '#a9c2de' },
          title: { display: true, text: 'ºC' }
        }
      },
      plugins: {
        legend: { labels: { color: '#cfe6ff' } },
        tooltip: {
          callbacks: {
            label: (ctx) => ` ${ctx.parsed.y.toFixed(1)} ºC`
          }
        }
      }
    }
  });

  // 8) Mensaje final
  msg.className = 'muted';
  msg.textContent = `Cargadas ${points.length} muestras.`;
})();
</script>
</body>
</html>
