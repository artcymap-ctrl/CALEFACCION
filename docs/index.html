<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Temperaturas horarias · Vitoria-Gasteiz (Foronda 9091R)</title>

  <!-- Luxon + Chart.js + adapter -->
  <script src="https://cdn.jsdelivr.net/npm/luxon@3/build/global/luxon.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-luxon@1.3.1/dist/chartjs-adapter-luxon.umd.min.js"></script>

  <style>
    :root{
      --bg:#0b1220; --card:#121a2b; --fg:#e7eef7; --muted:#9db0c6;
      --accent:#77b7ff; --ok:#27c93f; --warn:#ffbd2e; --err:#ff453a;
      --chip:#0e223e; --chip-b:#224b7a;
      --night:#0b1324;         /* banda noche */
      --night2:#0c1a33;        /* banda noche (alterno) */
      --grid:#1c2740;
    }
    *{box-sizing:border-box}
    body{margin:0;background:var(--bg);color:var(--fg);font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Helvetica,Arial}
    header{padding:18px 18px 8px 18px}
    h1{margin:0 0 4px 0;font-size:1.15rem}
    .sub{color:var(--muted);font-size:.9rem}

    main{padding:12px}
    .panel{background:var(--card);border:1px solid var(--grid);border-radius:14px;padding:12px;max-width:1400px;margin:0 auto}

    .row{display:flex;align-items:center;justify-content:space-between;gap:12px;flex-wrap:wrap}
    .left{display:flex;gap:10px;flex-wrap:wrap;align-items:center}

    .csvlink{color:#a9cfff;text-decoration:none}
    .csvlink:hover{text-decoration:underline}

    .chip{
      display:inline-flex;align-items:center;gap:8px;
      padding:6px 10px;border-radius:999px;background:var(--chip);
      border:1px solid var(--chip-b);font-size:.82rem;color:#cfe3ff
    }
    .chip .dot{width:8px;height:8px;border-radius:50%;background:var(--ok)}

    .controls{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    .controls label{font-size:.85rem;color:var(--muted)}
    .controls select{
      background:#0d1a2e;color:#cfe3ff;border:1px solid var(--grid);
      padding:6px 10px;border-radius:8px
    }

    .chart-wrap{position:relative;width:100%;height:60vh;min-height:360px}
    canvas{background:#0b1324;border:1px solid var(--grid);border-radius:8px;position:absolute;inset:0}

    .footok{color:var(--ok);margin-top:6px}
    @media (max-width: 640px){
      .chart-wrap{height:48vh}
    }
  </style>
</head>
<body>
  <header>
    <h1>Temperaturas horarias · Vitoria-Gasteiz (Foronda 9091R)</h1>
    <div class="sub">Fuente: AEMET · captura diaria automática · histórico incremental</div>
  </header>

  <main>
    <section class="panel">
      <div class="row" style="margin-bottom:8px">
        <div class="left">
          <span>CSV histórico:
            <a id="csvLink" class="csvlink" href="data/9091R_temp_history.csv" target="_blank" rel="noopener">data/9091R_temp_history.csv</a>
          </span>
          <div class="controls">
            <label for="station">Estación:</label>
            <select id="station">
              <!-- Estructura preparada por si añadimos más estaciones -->
              <option value="9091R" selected>9091R · Foronda</option>
            </select>

            <label for="range">Rango:</label>
            <select id="range">
              <option value="24h">Últimas 24h</option>
              <option value="48h">48h</option>
              <option value="7d">7 días</option>
              <option value="all" selected>Todo</option>
            </select>
          </div>
        </div>

        <div id="updateChip" class="chip" title="Última actualización detectada">
          <span class="dot"></span>
          <span id="updateText">Última actualización: …</span>
        </div>
      </div>

      <div class="chart-wrap">
        <canvas id="chart"></canvas>
      </div>

      <div id="okMsg" class="footok"></div>
    </section>
  </main>

<script>
(async function(){
  // Config
  const TZ = 'Europe/Madrid';
  const CSV_BY_STATION = (station) => `data/${station}_temp_history.csv`;
  const JSON_LAST = 'data/last_update.json';

  // DOM
  const csvLinkEl   = document.getElementById('csvLink');
  const updateText  = document.getElementById('updateText');
  const okMsg       = document.getElementById('okMsg');
  const ctx         = document.getElementById('chart').getContext('2d');
  const stationSel  = document.getElementById('station');
  const rangeSel    = document.getElementById('range');

  // Helper cache-busting
  const withBust = (url) => `${url}?t=${Date.now()}`;

  // --- Plugins -------------------------------------------------------------

  // 1) Líneas verticales a medianoche local
  const midnightLines = {
    id: 'midnightLines',
    beforeDraw(chart, args, opts){
      const {ctx, chartArea, scales} = chart;
      if(!chartArea || !scales?.x) return;
      const xScale = scales.x;

      const min = xScale.min; // ms epoch (con adapter-luxon)
      const max = xScale.max;
      if(!min || !max) return;

      // Iteramos por días (en zona local)
      let d = luxon.DateTime.fromMillis(min, {zone:TZ}).startOf('day').plus({days:1}); // primera medianoche dentro
      const last = luxon.DateTime.fromMillis(max, {zone:TZ}).endOf('day');

      ctx.save();
      ctx.strokeStyle = 'rgba(180,200,255,0.30)';
      ctx.lineWidth = 1;

      while(d <= last){
        const px = xScale.getPixelForValue(d.toJSDate());
        if(px >= chartArea.left && px <= chartArea.right){
          ctx.beginPath();
          ctx.moveTo(px, chartArea.top);
          ctx.lineTo(px, chartArea.bottom);
          ctx.stroke();
        }
        d = d.plus({days:1});
      }
      ctx.restore();
    }
  };

  // 2) Bandas de noche: 22:00–08:00 local (rectángulos de fondo)
  const nightBands = {
    id: 'nightBands',
    beforeDraw(chart){
      const {ctx, chartArea, scales} = chart;
      if(!chartArea || !scales?.x) return;
      const xScale = scales.x;

      const min = xScale.min, max = xScale.max;
      if(!min || !max) return;

      let d = luxon.DateTime.fromMillis(min, {zone:TZ}).startOf('day');
      const lastDay = luxon.DateTime.fromMillis(max, {zone:TZ}).endOf('day');

      ctx.save();
      while(d <= lastDay){
        const nightStart = d.set({hour:22});
        const nightEnd   = d.plus({days:1}).set({hour:8});

        const x1 = xScale.getPixelForValue(nightStart.toJSDate());
        const x2 = xScale.getPixelForValue(nightEnd.toJSDate());

        // alterna tonos para continuidad visual
        ctx.fillStyle = d.day % 2 === 0 ? 'rgba(20,30,60,0.35)' : 'rgba(16,24,46,0.35)';

        // Sólo pintar si interseca el área
        const left = Math.max(x1, chartArea.left);
        const right = Math.min(x2, chartArea.right);
        const width = right - left;

        if(width > 0){
          ctx.fillRect(left, chartArea.top, width, chartArea.bottom - chartArea.top);
        }
        d = d.plus({days:1});
      }
      ctx.restore();
    }
  };

  // 3) Etiquetas en min/max diarios
  const labelsPlugin = {
    id: 'labelsPlugin',
    afterDatasetsDraw(chart){
      const {ctx, chartArea} = chart;
      const dsMin = chart.data.datasets.find(d => d._role === 'min');
      const dsMax = chart.data.datasets.find(d => d._role === 'max');
      if(!dsMin && !dsMax) return;

      ctx.save();
      ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, Ubuntu';
      ctx.fillStyle = '#cfe6ff';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'bottom';

      [dsMin, dsMax].forEach(ds => {
        if(!ds) return;
        const meta = chart.getDatasetMeta(chart.data.datasets.indexOf(ds));
        meta.data.forEach((el, i) => {
          const {x, y} = el.getProps(['x','y'], true);
          const val = ds.data[i]?.y;
          if(typeof val === 'number' && x >= chartArea.left && x <= chartArea.right){
            const dy = ds._role === 'min' ? 14 : -6; // posición del texto respecto al punto
            ctx.fillText(`${val.toFixed(1)}º`, x, y + dy);
          }
        });
      });

      ctx.restore();
    }
  };

  Chart.register(midnightLines, nightBands, labelsPlugin);

  // --- Carga de datos ------------------------------------------------------

  // CSV -> { rows:[{x:Date,y:Number, dloc:DateTime}], lastUtc:Date }
  async function loadCSV(url){
    const res = await fetch(withBust(url));
    if(!res.ok) throw new Error(`HTTP ${res.status}`);
    const text = await res.text();

    const lines = text.trim().split(/\r?\n/);
    if(lines.length <= 1) return { rows:[], lastUtc:null };

    const header = lines[0].split(',');
    const idx = {
      dt:   header.indexOf('datetime_utc'),
      temp: header.indexOf('temp_c')
    };
    if(idx.dt < 0 || idx.temp < 0) throw new Error('Cabeceras inesperadas en CSV');

    const rows = [];
    for(let i=1;i<lines.length;i++){
      const parts = lines[i].split(',');
      if(parts.length<header.length) continue;

      const iso = parts[idx.dt];
      const t   = Number(parts[idx.temp]);
      if(!isFinite(t)) continue;

      const dtUTC  = luxon.DateTime.fromISO(iso, { zone:'utc' });
      if(!dtUTC.isValid) continue;

      const dtLoc  = dtUTC.setZone(TZ);     // local para agrupar por día/bandas
      rows.push({ x: dtUTC.toJSDate(), y: t, dloc: dtLoc });
    }
    rows.sort((a,b)=>a.x - b.x);

    const lastUtc = rows.length ? rows[rows.length-1].x : null;
    return { rows, lastUtc };
  }

  async function loadLastUpdateJSON(url){
    try{
      const r = await fetch(withBust(url));
      if(!r.ok) return null;
      return await r.json();
    }catch(_){ return null; }
  }

  // Filtrado por rango: '24h' | '48h' | '7d' | 'all'
  function filterByRange(rows, range){
    if(range === 'all' || rows.length === 0) return rows;
    const last = luxon.DateTime.fromJSDate(rows[rows.length-1].x, {zone:'utc'});
    let from = last;
    if(range==='24h') from = last.minus({hours:24});
    else if(range==='48h') from = last.minus({hours:48});
    else if(range==='7d')   from = last.minus({days:7});

    return rows.filter(r => luxon.DateTime.fromJSDate(r.x, {zone:'utc'}) >= from);
  }

  // Agrupa por día local → puntos min y max
  function computeDailyMinMax(rows){
    const groups = new Map(); // key: yyyy-MM-dd local
    for(const r of rows){
      const key = r.dloc.toFormat('yyyy-LL-dd');
      if(!groups.has(key)) groups.set(key, []);
      groups.get(key).push(r);
    }
    const mins = [], maxs = [];
    for(const [, arr] of groups){
      if(arr.length === 0) continue;
      let min = arr[0], max = arr[0];
      for(const p of arr){
        if(p.y < min.y) min = p;
        if(p.y > max.y) max = p;
      }
      mins.push({x:min.x, y:min.y});
      maxs.push({x:max.x, y:max.y});
    }
    // Orden cronológico
    mins.sort((a,b)=>a.x-b.x); maxs.sort((a,b)=>a.x-b.x);
    return {mins, maxs};
  }

  function drawChart(allRows){
    if(window.__chart) window.__chart.destroy();

    // Filtro por rango
    const range = rangeSel.value;
    const rows = filterByRange(allRows, range);

    // Min/Max diarios
    const {mins, maxs} = computeDailyMinMax(rows);

    window.__chart = new Chart(ctx, {
      type: 'line',
      data: {
        datasets: [
          {
            label: 'Temperatura (ºC)',
            data: rows,
            borderWidth: 2,
            pointRadius: 2,
            spanGaps: true,
            tension: 0.25
          },
          {
            label: 'Mínimo diario',
            _role: 'min',
            type: 'scatter',
            data: mins,
            pointRadius: 3.5,
            pointBackgroundColor: '#5dc3ff',
            pointBorderColor: '#5dc3ff',
            showLine: false
          },
          {
            label: 'Máximo diario',
            _role: 'max',
            type: 'scatter',
            data: maxs,
            pointRadius: 3.5,
            pointBackgroundColor: '#ffbd2e',
            pointBorderColor: '#ffbd2e',
            showLine: false
          }
        ]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        parsing: false,
        scales: {
          x: {
            type: 'time',
            adapters: { date: { zone: TZ } },
            time: { tooltipFormat: "dd/LL/yyyy HH:mm", displayFormats: { hour: "HH:mm" } },
            title: { display: true, text: 'Fecha y hora' },
            ticks: { maxRotation: 0, autoSkip: true }
          },
          y: {
            title: { display: true, text: 'ºC' },
            suggestedMin: Math.min(0, ...rows.map(d=>d.y)) - 1,
            suggestedMax: Math.max(10, ...rows.map(d=>d.y)) + 1
          }
        },
        plugins: {
          legend: { labels:{ color:'#cfe6ff' } },
          tooltip: {
            callbacks:{
              title(items){
                if(!items.length) return '';
                const d = luxon.DateTime
                  .fromJSDate(items[0].parsed.x, { zone: TZ });
                return d.toFormat("dd/LL/yyyy HH:mm");
              },
              label(it){ return `Temperatura (ºC): ${it.parsed.y.toFixed(1)}`; }
            }
          }
        }
      }
    });
  }

  // --- Flujo principal + eventos ------------------------------------------

  async function refresh(){
    try{
      const station = stationSel.value;
      const csvUrl  = CSV_BY_STATION(station);

      csvLinkEl.href = withBust(csvUrl);

      const { rows, lastUtc } = await loadCSV(csvUrl);
      const meta = await loadLastUpdateJSON(JSON_LAST);

      // Última actualización
      let label;
      if(meta && meta.updated_local){
        const dtLoc = luxon.DateTime.fromISO(meta.updated_local);
        if(dtLoc.isValid) label = dtLoc.toFormat("dd/LL/yyyy, HH:mm");
      }
      if(!label && lastUtc){
        const dtLoc = luxon.DateTime.fromJSDate(lastUtc).setZone(TZ);
        label = dtLoc.toFormat("dd/LL/yyyy, HH:mm");
      }
      if(!label){
        const dt = luxon.DateTime.fromJSDate(new Date(document.lastModified)).setZone(TZ);
        label = dt.toFormat("dd/LL/yyyy, HH:mm");
      }
      updateText.textContent = `Última actualización: ${label}`;

      // Dibuja
      drawChart(rows);

      okMsg.textContent = `OK: ${rows.length} registros.`;
      okMsg.style.color = 'var(--ok)';
    }catch(err){
      okMsg.textContent = `Error: ${err && err.message ? err.message : err}`;
      okMsg.style.color = 'var(--err)';
    }
  }

  // Primera carga
  await refresh();

  // Cambios de estación o rango
  stationSel.addEventListener('change', refresh);
  rangeSel.addEventListener('change', refresh);
})();
</script>
</body>
</html>
